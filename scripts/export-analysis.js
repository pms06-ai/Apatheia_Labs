#!/usr/bin/env node
/**
 * Export Analysis to Markdown
 * Generates apatheia-run.md for Obsidian vault
 */

const fs = require('fs');
const path = require('path');
const Database = require('better-sqlite3');

const CONFIG = {
  dbPath: path.join(process.env.APPDATA, 'com.apatheia.phronesis', 'phronesis.db'),
  caseId: 'obsidian-vault',
  vaultPath: 'C:\\Users\\pstep\\OneDrive\\Documents\\Obsidian Vault',
  outputPath: '40 - Analysis/apatheia-run.md'
};

function main() {
  if (!fs.existsSync(CONFIG.dbPath)) {
    console.error('Database not found');
    process.exit(1);
  }

  const db = new Database(CONFIG.dbPath, { readonly: true });

  // Get stats
  const docStats = db.prepare(`
    SELECT COUNT(*) as total
    FROM documents WHERE case_id = ?
  `).get(CONFIG.caseId);

  const findings = db.prepare(`
    SELECT * FROM findings WHERE case_id = ?
    ORDER BY
      CASE severity WHEN 'critical' THEN 1 WHEN 'high' THEN 2 WHEN 'medium' THEN 3 ELSE 4 END,
      engine
  `).all(CONFIG.caseId);

  // Get entities if table exists
  let entities = [];
  try {
    entities = db.prepare(`
      SELECT * FROM entities WHERE case_id = ? ORDER BY canonical_name
    `).all(CONFIG.caseId);
  } catch (e) {}

  // Summary by engine/severity
  const summary = {};
  for (const f of findings) {
    if (!summary[f.engine]) summary[f.engine] = { critical: 0, high: 0, medium: 0, low: 0 };
    summary[f.engine][f.severity] = (summary[f.engine][f.severity] || 0) + 1;
  }

  // Build markdown
  const now = new Date().toISOString();
  let md = `---
title: Apatheia Analysis Run
date: ${now.split('T')[0]}
case_id: ${CONFIG.caseId}
tags: [analysis, apatheia, automated]
---

# Apatheia Analysis Run

**Generated:** ${now}
**Case:** ${CONFIG.caseId}
**Documents Analyzed:** ${docStats.total}
**Total Findings:** ${findings.length}

---

## Summary by Engine

| Engine | Critical | High | Medium | Low | Total |
|--------|----------|------|--------|-----|-------|
`;

  for (const [eng, counts] of Object.entries(summary).sort()) {
    const total = counts.critical + counts.high + counts.medium + counts.low;
    md += `| ${eng} | ${counts.critical} | ${counts.high} | ${counts.medium} | ${counts.low} | ${total} |\n`;
  }

  md += `
---

## Findings by Engine

`;

  // Group findings by engine
  const byEngine = {};
  for (const f of findings) {
    if (!byEngine[f.engine]) byEngine[f.engine] = [];
    byEngine[f.engine].push(f);
  }

  for (const [engine, engineFindings] of Object.entries(byEngine)) {
    md += `### ${engine.replace(/_/g, ' ').toUpperCase()}\n\n`;
    for (const f of engineFindings) {
      const icon = f.severity === 'critical' ? 'ðŸ”´' :
                   f.severity === 'high' ? 'ðŸŸ ' :
                   f.severity === 'medium' ? 'ðŸŸ¡' : 'ðŸŸ¢';
      md += `#### ${icon} ${f.title}\n\n`;
      md += `**Severity:** ${f.severity || 'N/A'} | **Confidence:** ${(f.confidence * 100).toFixed(0)}%\n\n`;
      if (f.description) {
        md += `${f.description}\n\n`;
      }
      if (f.evidence && f.evidence !== '{}') {
        try {
          const ev = JSON.parse(f.evidence);
          if (ev.quotes && ev.quotes.length > 0) {
            md += `> ${ev.quotes[0]}\n\n`;
          }
        } catch (e) {}
      }
    }
  }

  // Entities
  if (entities.length > 0) {
    md += `---\n\n## Entities\n\n`;
    md += `| Name | Type | Role | Institution |\n`;
    md += `|------|------|------|-------------|\n`;
    for (const e of entities) {
      md += `| ${e.canonical_name} | ${e.entity_type} | ${e.role || '-'} | ${e.institution || '-'} |\n`;
    }
  }

  md += `\n---\n\n*Generated by Apatheia Labs - Phronesis Engine*\n`;

  // Write to vault
  const outputFile = path.join(CONFIG.vaultPath, CONFIG.outputPath);
  const outputDir = path.dirname(outputFile);

  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(outputFile, md);
  db.close();

  console.log(`Exported analysis to: ${outputFile}`);
  console.log(`Total Findings: ${findings.length}`);
  console.log(`Entities: ${entities.length}`);

  // Print summary
  console.log('\nSummary by Engine:');
  for (const [eng, counts] of Object.entries(summary).sort()) {
    const total = counts.critical + counts.high + counts.medium + counts.low;
    console.log(`  ${eng}: ${total} (${counts.critical} critical, ${counts.high} high)`);
  }
}

main();
